#include<iostream>
#include<opencv2/opencv.hpp>
#include<math.h>
#include<time.h>
#include<vector>
using namespace cv;
using namespace std;

template<class T>
T Clamp(T x, T min, T max)
{
	if (x > max)
		return max;
	if (x < min)
		return min;
	return x;
}

class localLaplacianFilter {

private:
	int imageWidth;
	int imageHeigh;
	// interface image
	float * srcGray;
	float * srcRgb;
	float * dstGray;
	float * dstRgb;

	// gaussion pyramid layer
	float * gaussLayer0; // w * h
	float * gaussLayer1; // w / 2 * h / 2
	float * gaussLayer2; // w / 4 * h / 4
	float * gaussLayer3; // w / 8 * h / 8;
	float * gaussLayer4; // w / 16 * h / 16;
	// laplacian pyramid layer
	float * lapLayer0; // w * h
	float * lapLayer1; // w / 2 * h / 2
	float * lapLayer2; // w / 4 * h / 4
	float * lapLayer3; // w / 8 * h / 8;
	float * lapLayer4; // w / 16 * h / 16;
	// usimage
	float * usLayer1; // w * h
	float * usLayer2; // w / 2 * h / 2
	float * usLayer3;// w / 4 * h / 4
	float * usLayer4;// w / 8 * h / 8
	// addimage
	float * addLayer0;
	float * addLayer1;
	float * addLayer2;
	float * addLayer3;

	// other params
	int radius = 2;
	float kernel[5][5];
	float kernelUs[5][5];
	// private func	
	void rgb2gray(float *rgb, int w, int h);

	float remapLuma(float delta, float g0, float sigma, float beta, float alpha);
	void remapLayer(float *lapLayer, int width, int heigh, float sigma, float beta, float alpha);

	void buildGaussPyramid();
	void buildLaplacianPyramid();
	void rebuildLaplacianPyramid();
	void remapLaplacianPyramid();
	float *calcResidualLayer(float * src, int width, int heigh);
	cv::Mat applyGainRgb();

	float* pydown(float * src, int w, int h);
	float* pyUp(float * src, int w, int h);
	float* imageSubstractOperator(float * src, float * usimage, int width, int heigh);

public:
	localLaplacianFilter(float *inRgb, int inWidth, int inHeigh);

	~localLaplacianFilter()
	{
		free(srcGray);
		free(srcRgb);
		free(dstGray);
		free(dstRgb);

		free(gaussLayer0);
		free(gaussLayer1);
		free(gaussLayer2);
		free(gaussLayer3);
		free(gaussLayer4);

		free(lapLayer0);
		free(lapLayer1);
		free(lapLayer2);
		free(lapLayer3);
		free(lapLayer4);

		free(usLayer1);
		free(usLayer2);
		free(usLayer3);
		free(usLayer4);

		free(addLayer0);
		free(addLayer1);
		free(addLayer2);
		free(addLayer3);
	}

	void run();
};

void writeRaw(float * image, int w, int h, string fn)
{
	string path = "./data/" + fn;
	FILE *fp = fopen(path.c_str(), "wb");
	unsigned char tmpVal = 0;
	for (int index = 0; index < (w * h); index++)
	{
		tmpVal = (unsigned char)(image[index] + 0.5f);
		fwrite(&tmpVal, sizeof(unsigned char), 1, fp);
	}
	fclose(fp);
}

void writeImage(float * image, int w, int h, string fn)
{
	string path = "./data/" + fn;
	FILE *fp = fopen(path.c_str(), "wb");

	cv::Mat dst(h, w, CV_8UC1);

	for (int row = 0; row < h; row++)
	{
		for (int col = 0; col < w; col++)
		{

			dst.at<uchar>(row, col) = (unsigned char)(image[row * w + col] + 0.5f);
		}
	}

	cv::imwrite(path + fn, dst);
}


void imshow(float * image, int width, int heigh, string name = "image", int channel = 1)
{
	return;
	float tmp;
	if (channel == 1)
	{
		cv::Mat gray(heigh, width, CV_8UC1);
		for (int row = 0; row < heigh; row++)
		{
			for (int col = 0; col < width; col++)
			{
				tmp = image[row * width + col];
				tmp = tmp > 255 ? 255 : tmp;
				tmp = tmp < 0 ? 0 : tmp;
				gray.at<uchar>(row, col) = tmp;
			}
		}
		cv::imshow(name, gray);
		cv::waitKey(0);
	}
	else if (channel == 3)
	{
		cv::Mat gray(heigh, width, CV_8UC3);
		for (int row = 0; row < heigh; row++)
		{
			for (int col = 0; col < width; col++)
			{
				gray.at<Vec3b>(row, col)[0] = image[row * width + col];
				gray.at<Vec3b>(row, col)[1] = image[heigh * width + row * width + col];
				gray.at<Vec3b>(row, col)[2] = image[heigh * width * 2 + row * width + col];
			}
		}
		cv::imshow(name, gray);
		cv::waitKey(0);
	}
	else
	{
		throw "input channel num error !";
	}
}

void localLaplacianFilter::rgb2gray(float *rgb, int w, int h)
{
	srcGray = (float *)malloc(sizeof(float) * imageHeigh * imageWidth);
	for (int row = 0; row < h; row++)
	{
		for (int col = 0; col < w; col++)
		{
			float B = rgb[row * w + col];
			float G = rgb[h * w + row * w + col];
			float R = rgb[h * w * 2 + row * w + col];
			float maxRGB = max(max(R, G), B);
			float gray = 0.25 * R + 0.5 * G + 0.25 * B;
			srcGray[row * w + col] = 0.5 * gray + maxRGB * 0.5;
		}
	}
}

localLaplacianFilter::localLaplacianFilter(float *inRgb, int inWidth, int inHeigh)
{
	// init w,h
	this->imageWidth = inWidth;
	this->imageHeigh = inHeigh;
	// malloc resource
	srcGray = (float *)malloc(sizeof(float) * imageHeigh * imageWidth);
	srcRgb = (float *)malloc(sizeof(float) * imageHeigh * imageWidth * 3);
	dstGray = (float *)malloc(sizeof(float) * imageHeigh * imageWidth);
	dstRgb = (float *)malloc(sizeof(float) * imageHeigh * imageWidth * 3);

	// init other params
	radius = 2;
	float kernelTmp[5][5] = {
	{1,4, 6, 4, 1},
	{4,16,24,16,4},
	{6,24,36,24,6},
	{4,16,24,16,4},
	{1,4, 6, 4, 1}
	};
	for (int row = 0; row < 5; row++)
	{
		for (int col = 0; col < 5; col++)
		{
			kernel[row][col] = kernelTmp[row][col];
			kernelUs[row][col] = kernelTmp[row][col];
		}
	}

	// gauss layer
	gaussLayer0 = (float *)malloc(sizeof(float) * imageHeigh * imageWidth);
	gaussLayer1 = (float *)malloc(sizeof(float) * imageHeigh / 2 * imageWidth / 2);
	gaussLayer2 = (float *)malloc(sizeof(float) * imageHeigh / 4 * imageWidth / 4);
	gaussLayer3 = (float *)malloc(sizeof(float) * imageHeigh / 8 * imageWidth / 8);
	gaussLayer4 = (float *)malloc(sizeof(float) * imageHeigh / 16 * imageWidth / 16);
	// laplacian layer
	lapLayer0 = (float *)malloc(sizeof(float) * imageHeigh * imageWidth);
	lapLayer1 = (float *)malloc(sizeof(float) * imageHeigh / 2 * imageWidth / 2);
	lapLayer2 = (float *)malloc(sizeof(float) * imageHeigh / 4 * imageWidth / 4);
	lapLayer3 = (float *)malloc(sizeof(float) * imageHeigh / 8 * imageWidth / 8);
	lapLayer4 = (float *)malloc(sizeof(float) * imageHeigh / 16 * imageWidth / 16);

	// usimage
	usLayer1 = (float *)malloc(sizeof(float) * imageHeigh * imageWidth);
	usLayer2 = (float *)malloc(sizeof(float) * imageHeigh / 2 * imageWidth / 2);
	usLayer3 = (float *)malloc(sizeof(float) * imageHeigh / 4 * imageWidth / 4);
	usLayer4 = (float *)malloc(sizeof(float) * imageHeigh / 8 * imageWidth / 8);

	// addLayer
	float * addLayer0 = (float*)malloc(sizeof(float) * imageWidth / 1 * imageHeigh / 1);
	float * addLayer1 = (float*)malloc(sizeof(float) * imageWidth / 2 * imageHeigh / 2);
	float * addLayer2 = (float*)malloc(sizeof(float) * imageWidth / 4 * imageHeigh / 4);
	float * addLayer3 = (float*)malloc(sizeof(float) * imageWidth / 8 * imageHeigh / 8);
	float * addLayer4 = (float*)malloc(sizeof(float) * imageWidth / 16 * imageHeigh / 16);


	// init srcRgb
	memcpy(srcRgb, inRgb, sizeof(float) * imageHeigh * imageWidth * 3);

	// rgb2y
	rgb2gray(srcRgb, imageWidth, imageHeigh);
	imshow(srcGray, imageWidth, imageHeigh, "srcGray", 1);
	writeRaw(srcGray, imageWidth, imageHeigh, "srcGray.raw");
	//writeImage(srcGray, imageWidth, imageHeigh, "srcGray.jpg");
}

void localLaplacianFilter::buildGaussPyramid()
{
	// gaussLayer0
	memcpy(gaussLayer0, srcGray, sizeof(float) * imageWidth * imageHeigh);
	// gaussLayer1
	gaussLayer1 = pydown(srcGray, imageWidth, imageHeigh);
	// gaussLayer2
	gaussLayer2 = pydown(gaussLayer1, imageWidth / 2, imageHeigh / 2);
	// gaussLayer3
	gaussLayer3 = pydown(gaussLayer2, imageWidth / 4, imageHeigh / 4);
	// gaussLayer4
	gaussLayer4 = pydown(gaussLayer3, imageWidth / 8, imageHeigh / 8);

	if (0)
	{
		imshow(gaussLayer0, imageWidth, imageHeigh, "gaussLayer0", 1);
		imshow(gaussLayer1, imageWidth / 2, imageHeigh / 2, "gaussLayer1", 1);
		imshow(gaussLayer2, imageWidth / 4, imageHeigh / 4, "gaussLayer2", 1);
		imshow(gaussLayer3, imageWidth / 8, imageHeigh / 8, "gaussLayer3", 1);
		imshow(gaussLayer4, imageWidth / 16, imageHeigh / 16, "gaussLayer4", 1);
	}
}

float *localLaplacianFilter::imageSubstractOperator(float * src, float * usimage, int width, int heigh)
{
	float res;
	float *residual = (float*)malloc(sizeof(float) * width * heigh);

	for (int row = 0; row < heigh; row++)
	{
		for (int col = 0; col < width; col++)
		{
			res = src[row * width + col] - usimage[row * width + col];
			res = res > 255 ? 255 : res;
			res = res < -255 ? -255 : res;
			residual[row * width + col] = res;
		}
	}
	return residual;
}

void localLaplacianFilter::buildLaplacianPyramid()
{
	lapLayer0 = calcResidualLayer(gaussLayer0, imageWidth, imageHeigh);
	lapLayer1 = calcResidualLayer(gaussLayer1, imageWidth / 2, imageHeigh / 2);
	lapLayer2 = calcResidualLayer(gaussLayer2, imageWidth / 4, imageHeigh / 4);
	lapLayer3 = calcResidualLayer(gaussLayer3, imageWidth / 8, imageHeigh / 8);
	memcpy(lapLayer4,gaussLayer4,sizeof(float) * imageWidth * imageHeigh / 16 / 16);


	if (0)
	{
		imshow(usLayer1, imageWidth, imageHeigh, "usLayer1", 1);
		imshow(usLayer2, imageWidth / 2, imageHeigh / 2, "usLayer2", 1);
		imshow(usLayer3, imageWidth / 4, imageHeigh / 4, "usLayer3", 1);
		imshow(usLayer4, imageWidth / 8, imageHeigh / 8, "usLayer4", 1);
	}
	if (0)
	{
		imshow(lapLayer0, imageWidth, imageHeigh, "lapLayer0", 1);
		imshow(lapLayer1, imageWidth / 2, imageHeigh / 2, "lapLayer1", 1);
		imshow(lapLayer2, imageWidth / 4, imageHeigh / 4, "lapLayer2", 1);
		imshow(lapLayer3, imageWidth / 8, imageHeigh / 8, "lapLayer3", 1);
		imshow(lapLayer4, imageWidth / 16, imageHeigh / 16, "lapLayer4", 1);
	}
}

float* imageAddOperator(float * src1, float *src2, int width, int heigh)
{
	float *resImage = (float*)malloc(width * heigh * sizeof(float));
	float tmp;
	float lap;
	for (int row = 0; row < heigh; row++)
	{
		for (int col = 0; col < width; col++)
		{
			lap = src2[row * width + col];
			tmp = src1[row * width + col] + lap;
			tmp = tmp > 255 ? 255 : tmp;
			tmp = tmp < 0 ? 0 : tmp;
			resImage[row * width + col] = tmp;
		}
	}
	return resImage;
}

void localLaplacianFilter::rebuildLaplacianPyramid()
{
	usLayer4 = pyUp(lapLayer4, imageWidth / 16, imageHeigh / 16);
	addLayer3 = imageAddOperator(usLayer4, lapLayer3, imageWidth / 8, imageHeigh / 8);
	

	usLayer3 = pyUp(addLayer3, imageWidth / 8, imageHeigh / 8);
	addLayer2 = imageAddOperator(usLayer3, lapLayer2, imageWidth / 4, imageHeigh / 4);

	usLayer2 = pyUp(addLayer2, imageWidth / 4, imageHeigh / 4);
	addLayer1 = imageAddOperator(usLayer2, lapLayer1, imageWidth / 2, imageHeigh / 2);

	usLayer1 = pyUp(addLayer1, imageWidth / 2, imageHeigh / 2);
	addLayer0 = imageAddOperator(usLayer1, lapLayer0, imageWidth, imageHeigh);
	imshow(addLayer0, imageWidth, imageHeigh, "addLayer0", 1);
}

inline float localLaplacianFilter::remapLuma(float delta, float g0, float sigma, float beta, float alpha)
{
	float diffAbs = abs(delta);
	int signV = delta >= 0.0 ? 1 : -1;
	if (diffAbs > sigma)
	{
		return (g0 + signV * ((diffAbs - sigma) * beta + sigma));
	}
	else
	{
		return (g0 + signV * pow(diffAbs / sigma, alpha) * sigma);
	}
}

void localLaplacianFilter::remapLayer(float *lapLayer, int width, int heigh, float sigma, float beta, float alpha)
{
	float tmpVal;
	for (int row = 0; row < heigh; row++)
	{
		for (int col = 0; col < width; col++)
		{
			tmpVal = lapLayer[row * width + col];
			tmpVal = remapLuma(tmpVal, 0, sigma, beta, alpha);
			lapLayer[row * width + col] = tmpVal;// *3.5;
		}
	}
}

void localLaplacianFilter::remapLaplacianPyramid()
{
	float sigma, beta, alpha;

	// layer0  w * h   lapLayer0
	//sigma = 50, beta = 1, alpha = 0.5;
	//remapLayer(lapLayer0, imageWidth, imageHeigh, sigma, beta, alpha );
	// layer1  w / 2 * h / 2  lapLayer1
	sigma = 40, beta = 1, alpha = 0.5;
	remapLayer(lapLayer1, imageWidth / 2, imageHeigh / 2, sigma, beta, alpha);

	// layer2   w / 4 * h / 4  lapLayer2;
	sigma = 30, beta = 1, alpha = 0.5;
	remapLayer(lapLayer2, imageWidth / 4, imageHeigh / 4, sigma, beta, alpha);
	// layer3   w / 8 * h / 8  lapLayer3; 
	sigma = 30, beta = 1, alpha = 0.5;
	remapLayer(lapLayer3, imageWidth / 8, imageHeigh / 8, sigma, beta, alpha);
	// layer4   w / 16 * h / 16 lapLayer4; 
	//sigma = 1, beta = 1, alpha = 0.5;
	//remapLayer(lapLayer4, imageWidth / 16, imageHeigh / 16, sigma, beta, alpha);
}

float* localLaplacianFilter::pyUp(float * src, int width, int heigh)
{
	float *usImage = (float *)malloc(sizeof(float) * 2 * width * 2 * heigh);

	int dstWidth = 2 * width;
	int dstHeigh = 2 * heigh;

	float src_v1, src_v2, src_v3, src_v4;
	int src_r1, src_r2, dst_r1, dst_r2, src_c1, src_c2, dst_c1, dst_c2;

	for (int row = 0; row <= heigh; row++)
	{
		src_r1 = Clamp(row - 1, 0, heigh - 1);
		src_r2 = Clamp(row, 0, heigh - 1);

		dst_r1 = Clamp((row << 1) - 1, 0, dstHeigh - 1);
		dst_r2 = Clamp((row << 1), 0, dstHeigh - 1);

		for (int col = 0; col <= width; col++)
		{
			src_c1 = Clamp(col - 1, 0, width - 1);
			src_c2 = Clamp(col, 0, width - 1);

			dst_c1 = Clamp((col << 1) - 1, 0, dstWidth - 1);
			dst_c2 = Clamp((col << 1), 0, dstWidth - 1);

			src_v1 = src[src_r1 * width + src_c1];
			src_v2 = src[src_r1 * width + src_c2];
			src_v3 = src[src_r2 * width + src_c1];
			src_v4 = src[src_r2 * width + src_c2];

			usImage[dst_r1 * dstWidth + dst_c1] = (9 * src_v1 + 3 * src_v2 + 3 * src_v3 + 1 * src_v4) / 16.0f;
			usImage[dst_r1 * dstWidth + dst_c2] = (3 * src_v1 + 9 * src_v2 + 1 * src_v3 + 3 * src_v4) / 16.0f;
			usImage[dst_r2 * dstWidth + dst_c1] = (3 * src_v1 + 1 * src_v2 + 9 * src_v3 + 3 * src_v4) / 16.0f;
			usImage[dst_r2 * dstWidth + dst_c2] = (1 * src_v1 + 3 * src_v2 + 3 * src_v3 + 9 * src_v4) / 16.0f;
		}
	}

	return usImage;
}

float* localLaplacianFilter::pydown(float * src, int width, int heigh)
{
	if (width % 4 != 0 || heigh % 4 != 0)
	{
		cout << "The width and height of the input must be divided by 4." << endl;
		throw "down sample error";
		return NULL;
	}

	float *dsImage = (float *)malloc(sizeof(float) * width * heigh / 4);
	unsigned int index = 0;
	for (int row = 0; row < heigh; row += 2)
	{
		for (int col = 0; col < width; col += 2)
		{
			dsImage[index] = (src[width * row + col] + src[width * (row + 1) + col] + src[width * (row + 1) + col + 1] + src[width * row + col + 1]) / 4.0f;
			index += 1;
		}
	}

	return dsImage;
}

float *localLaplacianFilter::calcResidualLayer(float * src, int width, int heigh)
{
	float * residuals = (float*)malloc(sizeof(float) * width * heigh);
	float * subWindow = (float *)malloc(sizeof(float) * 4 * 4);
	float * subWindowRemp = (float *)malloc(sizeof(float) * 4 * 4);
	float * subDownSample = (float *)malloc(sizeof(float) * 2 * 2);
	for (int row = 0; row < heigh; row++)
	{
		for (int col = 0; col < width; col++)
		{

			float g0 = src[row * width + col];

			int x_start = 0, y_start = 0;
			int w1 = 0, w2 = 0, w3 = 0, w4 = 0;
			if ((row % 2 == 0) && (col % 2 == 0))
			{
				x_start = col - 2;
				y_start = row - 2;
				w1 = 1; w2 = 3; w3 = 3; w4 = 9;
			}
			else if ((row % 2 == 1) && (col % 2 == 0))
			{
				x_start = col - 2;
				y_start = row - 1;
				w1 = 3; w2 = 9; w3 = 1; w4 = 3;
			}
			else if ((row % 2 == 0) && (col % 2 == 1))
			{
				x_start = col - 1;
				y_start = row - 2;
				w1 = 3; w2 = 1; w3 = 9; w4 = 3;
			}
			else if ((row % 2 == 1) && (col % 2 == 1))
			{
				x_start = col - 1;
				y_start = row - 1;
				w1 = 9; w2 = 3; w3 = 3; w4 = 1;
			}
			else {
				throw "x_start,y_start calc eror !";
			}
			x_start = Clamp(x_start, 0, width - 1);
			y_start = Clamp(y_start, 0, heigh - 1);

			for (int r = 0; r < 4; r++)
			{
				for (int c = 0; c < 4; c++)
				{
					int r_tmp = r + y_start;
					int c_tmp = c + x_start;
					r_tmp = Clamp(r_tmp, 0, heigh - 1);
					c_tmp = Clamp(c_tmp, 0, width - 1);
					subWindow[r * 4 + c] = src[r_tmp * width + c_tmp] - g0;
				}
			}
			// remap
			if (1)
			{
				for (int i = 0; i < 4; i++)
					for (int j = 0; j < 4; j++)
					{
						float sigma = 40, beta = 1, alpha = 1.5;
						float tmpVal = remapLuma(subWindow[i * 4 + j], 0, sigma, beta, alpha);
						subWindow[i * 4 + j] = tmpVal;
					}
			}
			// down sample
			subDownSample[0] = (subWindow[0] + subWindow[1] + subWindow[4] + subWindow[5]) / 4.0f;
			subDownSample[1] = (subWindow[2] + subWindow[3] + subWindow[6] + subWindow[7]) / 4.0f;
			subDownSample[2] = (subWindow[8] + subWindow[9] + subWindow[12] + subWindow[13]) / 4.0f;
			subDownSample[3] = (subWindow[10] + subWindow[11] + subWindow[14] + subWindow[15]) / 4.0f;
			// up sample
			float usP = (w1 * subDownSample[0] + w2 * subDownSample[1] + subDownSample[2] * w3 + subDownSample[3] * w4) / 16.0f;

			if (0)
			{

				//float sigma = 0.3, beta = 1, alpha = 0.5, noise = 0.01;

				//float tmpVal = usP;
				//float remapVal = tone_map_apply(abs(tmpVal) / 256.0f, sigma, beta, alpha, noise) * 256.0f;
				//if (tmpVal < 0)
				//{
				//	usP = -remapVal;
				//}
				//else {
				//	usP = remapVal;
				//}
			}
			residuals[row * width + col] = -usP;// abs(usP) * 16;
		}
	}
	free(subWindow);
	free(subWindowRemp);
	free(subDownSample);
	return residuals;
}

cv::Mat localLaplacianFilter::applyGainRgb()
{
	cv::Mat rgbEnhance(imageHeigh, imageWidth, CV_8UC3);
	for (int row = 0; row < imageHeigh; row++)
	{
		for (int col = 0; col < imageWidth; col++)
		{
			float src = srcGray[row * imageWidth + col];
			float dst = dstGray[row * imageWidth + col];
			float gain = src == 0 ? 1.0 : (dst / src);

			float B = srcRgb[row * imageWidth + col] * gain;
			float G = srcRgb[imageHeigh * imageWidth + row * imageWidth + col] * gain;
			float R = srcRgb[imageHeigh * imageWidth * 2 + row * imageWidth + col] * gain;

			B = B > 255 ? 255 : B;
			B = B < 0 ? 0 : B;
			G = G > 255 ? 255 : G;
			G = G < 0 ? 0 : G;
			R = R > 255 ? 255 : R;
			R = R < 0 ? 0 : R;
			rgbEnhance.at<Vec3b>(row, col)[0] = B;
			rgbEnhance.at<Vec3b>(row, col)[1] = G;
			rgbEnhance.at<Vec3b>(row, col)[2] = R;
		}
	}
	return rgbEnhance;
}

void rgb2raw(cv::Mat rgb)
{
	char path[256] = "./data/face.raw";
	int imageWidth = rgb.cols;
	int imageHeigh = rgb.rows;
	unsigned char * rawBuffer = (unsigned char *)malloc(sizeof(unsigned char) * imageHeigh * imageWidth * 3);
	FILE *fpRgb = fopen(path, "wb");
	int indexx = 0;
	for (int row = 0; row < imageHeigh; row++)
		for (int col = 0; col < imageWidth; col++)
		{
			for (int c = 0; c < rgb.channels(); c++)
			{
				indexx = imageWidth * imageHeigh * c;
				rawBuffer[indexx + row * imageWidth + col] = (unsigned char)rgb.at<Vec3b>(row, col)[c];

			}
		}
	fwrite(rawBuffer, sizeof(unsigned char) * imageHeigh * imageWidth * 3, 1, fpRgb);
	fclose(fpRgb);
}


void readRgbImage(float * rgb, int w, int h)
{
	char path[256] = "./data/face.raw";
	int imageWidth = w;
	int imageHeigh = h;
	unsigned char * rawBuffer = (unsigned char *)malloc(sizeof(unsigned char) * imageHeigh * imageWidth * 3);
	FILE *fpRgb = fopen(path, "rb");
	fread(rawBuffer, sizeof(unsigned char) * imageWidth * imageHeigh * 3, 1, fpRgb);
	for (int index = 0; index < imageWidth * imageHeigh * 3; index++)
	{
		rgb[index] = (float)rawBuffer[index];
	}
}

void localLaplacianFilter::run()
{
	buildGaussPyramid();
	buildLaplacianPyramid();
	rebuildLaplacianPyramid();

	memcpy(dstGray,addLayer0,sizeof(float) * imageWidth * imageHeigh);

	cv::Mat rgbEnhance(imageHeigh, imageWidth, CV_8UC3);
	rgbEnhance = applyGainRgb();
	cv::imwrite("./data/dxoMark/OCTdstperson1.5.jpg.jpg", rgbEnhance);
}

void llfRun()
{
	cv::Mat srcImage = cv::imread("./data/dxoMark/person.jpg", IMREAD_UNCHANGED);
	cv::resize(srcImage, srcImage, cv::Size(4096, 3072));
	cv::imwrite("./data/dxoMark/person.jpg", srcImage);
	printf("srcImage width = %d,heigh = %d\n", srcImage.cols, srcImage.rows);

	rgb2raw(srcImage);
	float *srcRgb = (float *)malloc(sizeof(float) * srcImage.cols * srcImage.rows * 3);

	readRgbImage(srcRgb, srcImage.cols, srcImage.rows);

	localLaplacianFilter laplacianFilter(srcRgb, srcImage.cols, srcImage.rows);
	laplacianFilter.run();
}
