float* localLaplacianFilter::pyUp(float * src, int width, int heigh)
{
    float *usImage = (float *)malloc(sizeof(float) * 2 * width * 2 * heigh);

    int dstWidth = 2 * width;
    int dstHeigh = 2 * heigh;

    float src_v1,src_v2, src_v3, src_v4;
    int src_r1, src_r2, dst_r1, dst_r2, src_c1, src_c2, dst_c1, dst_c2;

    for (int row = 0; row <= heigh; row++)
    {
        src_r1 = Clamp(row - 1,0, heigh - 1);
        src_r2 = Clamp(row, 0, heigh - 1);

        dst_r1 = Clamp((row << 1) - 1, 0, dstHeigh - 1);
        dst_r2 = Clamp((row << 1), 0 , dstHeigh - 1);

        for (int col = 0; col <= width; col++)
        {
            src_c1 = Clamp(col - 1,0, width - 1);
            src_c2 = Clamp(col,0, width - 1);

            dst_c1 = Clamp((col << 1) - 1, 0 ,dstWidth - 1);
            dst_c2 = Clamp((col << 1),0 , dstWidth - 1);
            
            src_v1 = src[src_r1 * width + src_c1];
            src_v2 = src[src_r1 * width + src_c2];
            src_v3 = src[src_r2 * width + src_c1];
            src_v4 = src[src_r2 * width + src_c2];
            
            usImage[dst_r1 * dstWidth + dst_c1] = (9 * src_v1 + 3 * src_v2 + 3 * src_v3 + 1 * src_v4) / 16.0f;
            usImage[dst_r1 * dstWidth + dst_c2] = (3 * src_v1 + 9 * src_v2 + 1 * src_v3 + 3 * src_v4) / 16.0f;
            usImage[dst_r2 * dstWidth + dst_c1] = (3 * src_v1 + 1 * src_v2 + 9 * src_v3 + 3 * src_v4) / 16.0f;
            usImage[dst_r2 * dstWidth + dst_c2] = (1 * src_v1 + 3 * src_v2 + 3 * src_v3 + 9 * src_v4) / 16.0f;
        }
    }

    return usImage;
}
float* localLaplacianFilter::pydown(float * src, int width, int heigh, int radius, float kernel[][5])
{
    if (width % 4 != 0 || heigh % 4 != 0)
    {
        cout << "The width and height of the input must be divided by 4." << endl;
        throw "down sample error";
        return NULL;
    }

    float *dsImage = (float *)malloc(sizeof(float) * width * heigh / 4);
    unsigned int index = 0;
    for (int row = 0; row < heigh; row += 2)
    {
        for (int col = 0; col < width; col += 2)
        {   
            dsImage[index] = (src[width * row + col] + src[width * (row + 1) + col] + src[width * (row + 1) + col + 1] + src[width * row + col + 1]) / 4.0f;
            index += 1;
        }
    }

    return dsImage;
}

float *localLaplacianFilter::calcResidualLayer(float * src,int width, int heigh)
{
    float * residuals = (float*)malloc(sizeof(float) * width * heigh);
    float * subWindow = (float *)malloc(sizeof(float) * 4 * 4);
    float * subWindowRemp = (float *)malloc(sizeof(float) * 4 * 4);
    float * subDownSample = (float *)malloc(sizeof(float) * 2 * 2); 
    for (int row = 0; row < heigh; row++)
    {
        for (int col = 0; col < width; col++)
        {

            float g0 = src[row * width + col];

            int x_start = 0, y_start = 0;
            int w1 = 0, w2 = 0, w3 = 0, w4 = 0;
            if ((row % 2 == 0) && (col % 2 == 0))
            {
                x_start = col - 2;
                y_start = row - 2;
                w1 = 1; w2 = 3; w3 = 3; w4 = 9;
            }
            else if ((row % 2 == 1) && (col % 2 == 0))
            {
                x_start = col - 2;
                y_start = row - 1;
                w1 = 3; w2 = 9; w3 = 1; w4 = 3;
            }
            else if ((row % 2 == 0) && (col % 2 == 1))
            {
                x_start = col - 1;
                y_start = row - 2;
                w1 = 3; w2 = 1; w3 = 9; w4 = 3;
            }
            else if ((row % 2 == 1) && (col % 2 == 1))
            {
                x_start = col - 1;
                y_start = row - 1;
                w1 = 9; w2 = 3; w3 = 3; w4 = 1;
            }
            else {
                throw "x_start,y_start calc eror !";
            }
            x_start = Clamp(x_start, 0, width - 1);
            y_start = Clamp(y_start, 0, heigh - 1);

            for (int r = 0; r < 4; r++)
            {
                for (int c = 0; c < 4; c++)
                {
                    int r_tmp = r + y_start;
                    int c_tmp = c + x_start;
                    r_tmp = Clamp(r_tmp, 0, heigh - 1);
                    c_tmp = Clamp(c_tmp, 0, width - 1);
                    subWindow[r * 4 + c] = src[r_tmp * width + c_tmp] - g0;
                }
            }
            // remap
            if (remapEnable == 1)
            {
                for (int i = 0; i < 4; i++)
                    for (int j = 0; j < 4; j++)
                    {
                        float sigma = 0.3, beta = 1, alpha = 0.5,noise = 0.01;

                        float tmpVal = subWindow[i * 4 + j];
                        float remapVal = tone_map_apply(abs(tmpVal) / 256.0f, sigma, beta, alpha, noise) * 256.0f;
                        if (tmpVal < 0)
                        {
                            subWindow[i * 4 + j] = -remapVal;
                        }
                        else {
                            subWindow[i * 4 + j] = remapVal;
                        }
                    }
            }
            // down sample
            subDownSample[0] = (subWindow[0] + subWindow[1] + subWindow[4] + subWindow[5]) / 4.0f;
            subDownSample[1] = (subWindow[2] + subWindow[3] + subWindow[6] + subWindow[7]) / 4.0f;
            subDownSample[2] = (subWindow[8] + subWindow[9] + subWindow[12] + subWindow[13]) / 4.0f;
            subDownSample[3] = (subWindow[10] + subWindow[11] + subWindow[14] + subWindow[15]) / 4.0f;
            // up sample
            float usP = (w1 * subDownSample[0] + w2 * subDownSample[1] + subDownSample[2] * w3 + subDownSample[3] * w4) / 16.0f;

             if (remapEnable == 0)
            {

                float sigma = 0.3, beta = 1, alpha = 0.5,noise = 0.01;

                float tmpVal = usP;
                float remapVal = tone_map_apply(abs(tmpVal) / 256.0f, sigma, beta, alpha, noise) * 256.0f;
                if (tmpVal < 0)
                {
                    usP = -remapVal;
                }
                else {
                    usP = remapVal;
                }
            }
            residuals[row * width + col] = -usP;// abs(usP) * 16;
        }
    }
    free(subWindow);
    free(subWindowRemp);
    free(subDownSample);
    return residuals;
}


